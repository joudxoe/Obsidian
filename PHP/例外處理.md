要點整理
- 例外/異常是程式的運行出現不符合預期的情況，屬邏輯上的錯誤而非編譯或語法的錯誤
- 使用`throw`和`try...catch`語句處理例外
- 當例外被拋出時，之後的程式不會繼續執行，PHP會尋找符合的catch程式區塊
- 當try區塊中的程式碼發生異常時，可以使用throw語句丟出異常，之後由catch區塊捕獲
- try區塊檢查是否產生例外，當例外產生使用throw拋出例外，catch區塊處理丟出的例外
- 當異常觸發時，每一個throw必須至少對應一個catch區塊
- 使用多個catch區塊可以補捉不同種類的例外
- 若例外沒有被捕捉，將發生嚴重錯誤並輸出Uncaught Exception(未捕捉例外)的錯誤訊息
- 繼承Exception類別來建立自定義的例外處理(Handling Exceptions)
- 自定義例外處理類別必須是Exception類別的擴充，發生例外時，呼叫自定義例外的函數
- 所有未捕捉的例外都可以透過頂層例外處理器來處理
- 頂層例外處理器使用`set_exception_handler()`函數來實現
- `set_exception_handler()`用來設置所有未捕獲異常的用戶定義函數

例外/異常的錯誤處理方法
* 例外的基本處理
* 自定義例外處理器
* 多個異常
* 重新拋出例外
* 設置頂層例外處理器

try...catch...finally
```
try {

} catch (Exception $exception) {

} finally {

}
```

建立可拋出例外的函數
```
function validPassword($password){
	if(trim($password)=='') throw new Exception('密碼為空字串');
	if(strlen($password)<6) throw new Exception('密碼長度太短');
	if(is_numeric($password)) throw new Exception('密碼需包含字符');
	return true;
}
```

在try區塊觸發例外，catch區塊捕捉例外
```
try{
	validPassword('12345');
}catch(Exception $e){
	echo $e->getMessage();
	exit;
}
```

自訂例外處理器
```
class customException extends Exception{
	public function errorMessage(){
		return $error=$this->getMessage().'不是一個有效的電子郵件地址';
	}
}
```

```
$email='jane&gmail.com';
try{
	if(filter_var($email, FILTER_VALIDATE_EMAIL) === FALSE){
		throw new csutomException($email);
	}
}catch(customException $e){
	echo $e->errorMessage();
}
```

開啟檔案的例外處理
```
$DOCUMENT_ROOT=$_SERVER['DOCUMENT_ROOT'];
@$fp=fopen("$DOCUMENT_ROOT/log.txt",'rb');
try{
	if(!$fp) throw new Exception('找不到檔案或檔案路徑有誤');
}catch(Exception $e){
	echo $e->getMessage();
	echo '在檔案'.$e->getFile().'的'.$e->getLine().'行';
}
@fclose($fp);
```

設置頂層例外處理器
```
function uncaughtException($exception){
	echo 'Exception: '.$exception->getMessage();
}
set_exception_handler('uncaughtException');
throw new Exception('Uncaught Exception occurred');
```