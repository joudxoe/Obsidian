**物件導向的三大特性	**

- 封裝(encapsulation)

>將變數和函式包裝成[[類別]]，並設定存取範圍避免外部直接存取

- [[繼承]](inheritance)

>繼承即有類別的非私有成員來建立新的類別，並擴充新類別的屬性和方法
>
>子類別可以重新定義繼承自父類別的屬性和方法，使其獲得與父類別不同的功能
>
>子類別若使用和父類別同名的屬性和方法，會產生覆寫的效果
>
>PHP支援單繼承，也就是一個子類別只能有一個父類別，但父類別可以有多個子類別
>
>即有類別稱為基底類別/基礎類別/父類別/超類別
>
>繼承的類別稱為衍生類別/派生類別/擴充類別/子類別
>
>繼承的主要目的是==擴充即有類別的功能==，來衍生功能更多且更複雜的類別

- 多型(polymorphism)

>不同的類別對於相同的方法有不同的行為/執行結果
>
>子類別重新定義/覆蓋繼承自父類別的方法，且不影響父類別原本的方法
>
>透過覆蓋(override)的技巧來實作多型
>
>超載即是在子類別重新定義父類別的方法
>
>實現多型的方法有兩種: 透過繼承實現多型 / 透過[[介面]]實現多型

**類別的成員**

- 屬性(property)
- 方法(method)
- 常數(constant)

- 建構式(constructor)

>在建立物件時自動執行，可用來初始化物件
>
>透過new關鍵字產生實例的時候，就會被呼叫執行
	
- 解構式(destructor)

>在物件結束/被銷毀時自動執行，用來釋放物件佔用的系統資源
>
>PHP具有垃圾回收機制，可以自動清除不再使用的物件，以釋放更多的記憶體
	
**物件成員的存取範圍**

- Public - 定義的成員是公開的，可在任何地方存取呼叫
- Protected - 定義的成員是保護的，只提供定義的類別及繼承的子類別存取呼叫
- Private - 定義的成員是私有的，只能在定義的類別中存取呼叫

***

**補充資料**

1. 超載/覆寫/覆載(Override): 在子類別重新定義父類別的方法，且不影響父類別
2. 使用class關鍵字定義類別，使用new運算子建立物件
3. 類別是物件的原型/範本/抽象，需先定義類別才能建立物件/實例/實體
4. 使用類別建立的物件稱為實例(Instances)
5. 定義類別後必須建立物件才能使用它，稱為實例化類別也就是建立類別的實例
6. 偽變數$this指的是物件本身，不是變數，代表物件的關鍵子
7. 使用static關鍵字定義靜態成員，可直透過類別名稱和::運算子呼叫，不必建立類別的物件
8. PHP不支援多重繼承，也就是子類別只能繼承自一個父類別，但父類別可以有多個子類別
9. PHP支援鏈狀繼承，B類別繼承自A類別，C類別繼承自B類別
10. PHP提供兩種機制來實做多重繼承，介面(Interfaces)和特徵(trais)
11. 在當前類別透過self關鍵字和::運算子存取常數，self關鍵字代表當前類別
12. 定義父類別的方法時加上final關鍵字，可防止子類別覆蓋父類別的方法
13. 如果一個類別被宣告為final，則不能被繼承
14. final方法不能被重新定義，final類別不能被繼承
15. 與類別同名的函式也是建構式，PHP5之後使用__consturct()，不使用同物件名的函式
16. 將物件的值設定為NULL，就是釋放物件，此時會自動執行解構函式
17. ::運算子可用來存取類別內的靜態成員、類別內的常數和被覆蓋的成員
18. 物件導向的三大特性有次序性，沒有封裝就沒有繼承，沒有繼承就沒有多型
19. ::運算子可以在沒有宣告實例的情況下存取類別中的成員
20. 不允許外部存取的成員，就設定為私有的
21. 允許透過繼承的方式存取成員，就設定為保護的
22. 受保護的成員只有自身類和繼承類可存取呼叫
23. 封裝、繼承、多型有次序性，有封裝才有繼承，有繼承才有多型
24. 變數或屬性賦值的行為，就視為變數和屬性的初始化
25. 透過開放的函式傳出私有成員的值，即可取得私有成員的屬性值
26. 為了區別開放成員和私有成員，私有成員的命名前會加上一個底線