##### 物件導向的三大特性
- 封裝(encapsulation)

	*將變數和函式包裝成類別，並設定存取範圍*

- 繼承(inheritance)

	*繼承即有類別的非私有成員來建立新的類別，並擴充新類別的屬性和方法*
	*子類別可以重新定義繼承自父類別的屬性和方法，使其獲得與父類別不同的功能*
	*PHP支援單繼承，也就是一個子類別只能有一個父類別，但父類別可以有多個子類別*

- 多型(polymorphism)

	*不同的類別對於相同的方法有不同的行為*
	*子類別重新定義繼承自父類別的方法，且不影響父類別原本的方法*

##### 類別的成員

- 屬性(property)

- 方法(method)

- 常數(constant)

- 建構式(constructor)

	*在建立物件時自動執行，可用來初始化物件*
	*透過new關鍵字產生實例的時候，就會被呼叫執行*
	
- 解構式(destructor)

	*在物件結束/被銷毀時自動執行，用來釋放物件佔用的系統資源*
	*PHP具有垃圾回收機制，可以自動清除不再使用的物件，以釋放更多的記憶體*
	
##### 物件成員的存取範圍

- Public - 定義的成員是公開的，可在任何地方存取呼叫
- Protected - 定義的成員是保護的，只提供定義的類別及繼承的子類別存取呼叫
- Private - 定義的成員是私有的，只能在定義的類別中存取呼叫	

***

##### 補充資料

1. 超載/覆寫/覆載(Override): 在子類別重新定義父類別的方法，且不影響父類別
2. 使用class關鍵字定義類別，使用new運算子建立物件
3. 類別是物件的原型/範本/抽象，需先定義類別才能建立物件
4. 使用類別建立的物件稱為實例(Instances)
5. 定義類別後必須建立物件才能使用它，稱為實例化類別也就是建立類別的實例
6. $this指的是物件本身，不是變數，代表物件的關鍵子
7. 使用static關鍵字定義靜態成員，可直透過類別名稱和::運算子呼叫，不必建立類別的物件
8. PHP不支援多重繼承，也就是子類別只能繼承自一個父類別，但父類別可以有多個子類別
9. PHP支援鏈狀繼承
10. PHP提供兩種機制來實做多重繼承，介面(Interfaces)和特徵(trais)
11. 在當前類別透過self關鍵字和::運算子存取常數，self關鍵字代表當前類別
12. 定義父類別的方法時加上final關鍵字，可防止子類別覆蓋父類別的方法
13. 如果一個類別被宣告為final，則不能被繼承
14. 與類別同名的函式也是建構式，PHP5之後使用__consturct()，不使用同物件名的函式
15. 將物件的值設定為NULL，就是釋放物件，此時會自動執行解構函式
16. ::運算子可用來存取類別內的靜態成員、類別內的常數和被覆蓋的成員
17. 物件導向的三大特性有次序性，沒有封裝就沒有繼承，沒有繼承就沒有多型
18. ::運算子可以在沒有宣告實例的情況下存取類別中的成員